# ログイン機能
## 機能作成の流れ
- ユーザーテーブル定義
- DB接続
- 新規ユーザー登録機能 + 画面
- ログイン機能 + 画面
- ログアウト機能
- マイページ画面

## ユーザーテーブル定義
テーブル名：users

| カラム名 | データ型 | 長さ | その他 |
| -------- | -------- | ---- | ------ |
| id       | INT(UNSIGNED)      | 11   | A.I    |
| name     | VARCHAR            | 64   |        |
| email    | VARCHAR            | 191  | UNIQUE |
| password | VARCHAR            | 191  |        |

## DB接続

## 新規ユーザー登録機能
- フォームからデータを渡す
- フォームの値をバリデーションする
- ユーザー情報をDBに登録する
### フォームの内容
- ユーザー名
- メールアドレス
- パスワード
- 確認用パスワード

## フォームの値をバリデーションする
- 名前とメールアドレスの空文字チェック
- パスワードと確認用パスワードが同一になっているか
- パスワードが英数字8文字以上100文字以下になっているか（セキュリティ強度によって変わる）
- 条件を満たさなければ、エラー用配列にエラーメッセージを格納しておく

## ユーザー情報をDBに登録する
- フォームの値をバリデーションした結果、エラーの数が0であれば登録処理を実行する
- DBに登録するメソッドは、入力値をexecute時にバインドできるように配列にまとめる→INSERT文をprepareしてプリペアードステートメントを取得→executeで入力値の配列をバインドするの流れで実行する。また、DBへの処理なので、例外処理を入れる。

### ポイント
- バリデーションでは、何をバリデートするべきか検討する
- パスワードはハッシュ化する
- エラーはバリデーションに引っかかった分だけ出力したいので、配列に入れていくようにする
- パスワードのバリデーションは正規表現で英数字や文字数などをチェックするようにする
- DBに処理を行う場合は、必ず例外処理を入れておくことに注意する
- DBに登録するなどのロジックと、HTMLの画面はファイルを分ける（ロジック用のクラス・メソッドを用意して、それを画面側からrequireしてメソッドを実行する）

## ログイン機能
1. emailとpasswordを受け取る
2. emailと一致するユーザーを検索
3. passwordが一致するか検証
4. ユーザー情報をセッションに格納
→ログイン

### セッション
- 開始から終了までの期間
- 例えば、1ユーザーのログインからログアウトまでの行動は1セッション
- 1セッションはセッションIDで管理
- HTTPはステートレスなので、ユーザーを識別するためにセッションが必要（ログインからログアウトまでの行動は、このユーザーがやっていますというのを管理できる）
- セッションの管理はCookieでできる

### Cookie
- ブラウザに保存される情報
- セッションIDをブラウザに保存できる

1. フォームでユーザー情報を送信する
2. emailを元に、ユーザ情報があっているか確認
3. あっていればログイン成功。サーバーからセッションIDを発行する。
4. セッションIDをクッキーに保存
5. クッキーに保存したセッションIDをリクエスト時に一緒に送信することで、サーバー側でユーザーを識別できる

### セッションの扱い方
- session_start
→ CookieにセッションIDを入れる
→ セッションファイルが生成される
→ セッションファイルに自由に値を保存可能
→ 実際の現場では、セッションを入れる用のDBを用意して管理することが多い
→session_startは、実行時にセッションCookieがあればそのまま使い、なければ新たに発行するという動きをする（session_start時に毎回新規にセッションIDを発行する訳ではない）

- session_destroy
→ セッションファイルを削除
→ ログインのバリデーションメッセージを表示するときなどは、セッションで保存していたエラーメッセージ配列を別の変数に格納して、session_destroyと$_SESSIONを空配列で初期化すれば、セッションを一度きりで使うことができる。

- $_SESSION
→ セッションへデータを連想配列で保存
→この変数にデータを格納すると、セッションファイルにそのデータが入る

### パスワード照会
- password_verify
	- DBでハッシュ化して保存されているパスワードと、平文のパスワードを照会することができる

### セッションハイジャック
- セッションIDを盗まれて、なりすましをされること
- セッションIDはログインしてからログアウトするまで同じものが使われるので、セッションID生成〜ログイン認証の間にIDを盗まれてしまうと、なりすましをされてしまう恐れがある
- 対策：ログイン成功後の処理に、session_regenerate_idでセッションIDを再生成する。→その後に、$_SESSION変数にログイン状態を保存する
- ここでのセッションハイジャックはセッション固定化攻撃のことで、攻撃者が予め用意しておいたIDを相手に仕掛け、その状態で相手が何かのサイトにログインした時に攻撃者はセッションIDを知っているので、それを使ってその相手になりすましてしまうこと。そのため、ログインした直後にセッションIDを再生成する必要がある

### ログイン機能で考慮すべきセキュリティ対策
- CSRF対策
- XSS対策
- 二重送信防止
- ID、パスワードへの攻撃対策

#### CSRF対策
- Web利用者が意図しない、偽造されたリクエストが実行されてしまう脆弱性
→ 対策：ワンタイムトークンを使う

#### XSS対策
- Webページにアクセスすることで不正なスクリプトが実行される脆弱性
→ 対策：エスケープ処理をする

#### 二重送信防止
- 送信ボタン連打による多重送信・登録中の画面で何度もリロードされ、多重のリクエストが送信される・登録後にブラウザバックされ登録処理が再度走ってしまう
→ 対策：ワンタイムトークンを使う

#### ID、パスワードへの攻撃対策
- ブルートフォースアタック（総当たり攻撃）
→対策：ログイン失敗の回数ロックをかける、ワンタイムパスワードにする、2要素認証にする

### ワンタイムトークンの実装方法
- トークンを生成する関数を作成する
	- bin2hex()の引数に、random_bytes(32)を入れることで、セキュリティに強いランダム文字列を生成する
	- セッションにcsrf_tokenとして、上で生成したトークンを格納する
	- トークンをreturnする（セッションに格納した値と、POSTで送信する値が一致するかどうか検証するため）
- フォームに`<input type="hidden" name="csrf_token" value="<?php echo h(setToken()); ?>">` でトークンを入れ込む（setTokenがトークン生成の関数、hがエスケープ用関数）
- フォーム送信先の画面で、トークンの値が正しいか検証する
	- POSTから受け取ったトークンを取得する（fiter_input or $_POST）
	- POSTからのトークンがセットされていない、またはPOSTのセッションから取得したトークンとセッションから取得したトークンが一致しない場合には、exitして処理を終了させる
	- チェック完了後は、セッションのトークンをunsetしてトークンを削除する（リロードなど、新規登録フォームからの送信ではなく二重送信された場合にも、2回目にはセッションのトークンはunsetで削除されているのでチェックで引っかかってexitする）

### ログイン後の流れ
1. ログインユーザーを表示する画面へ
2. ログインしているかどうかはSessionで判定
3. ログインしていなかったら新規画面へ
4. ログインしていたらユーザーを表示（新規登録画面とログイン画面もログイン時には表示しないようにしたいので、ログイン時にはマイページにリダイレクトするようにする）

### ログインチェックのやり方
- セッションに入れたユーザーをチェック
	- $_SESSION['login_user'];
- チェックする関数を作る
	- セッションの中身がセットされているか？
- 作った関数を各ページの最初に埋め込む
	- ログインと新規登録にも埋め込む（表示する必要はないので）

### ログインファイル修正
- 現在：login.php -> (POST) top.php
- 修正後：login_form.php -> (POST) login.php -> (GET) my_page.php
- データを送信するページと、コンテンツを表示するだけのページはPOSTとGETで分けたほうが分かりやすいから

### ログアウト機能作成の流れ
1. ログアウトボタンクリック（formのactionにログアウト処理のファイルを指定してその中にinputタグを作って、ログアウトファイルに遷移する）→ リンクだと直でリンクを打った時に、その時点でログアウトしてしまうため。$_POST['logout']（form内の`<input type="submit" name="logout">`で送信）があればログアウト処理に進むようにする
2. formのinput submitのnameで指定したキーから値が取得できるかチェックし、取得できなければformを介していないので不正なリクエストとしてexitする。
3. Sessionがあるかどうかチェックし、なければセッション切れなのでログインし直す旨を表示してexitする。
4. セッションを削除して、ログアウト画面で、ログアウト完了した旨とログイン画面へのリンクを出力する。

### ログアウト機能
- PHPのドキュメント（https://www.php.net/manual/ja/function.session-destroy.php）を参考にセッションを削除する
